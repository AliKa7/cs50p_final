# FRACTALS DRAWER
#### Video Demo:  <URL HERE>
#### Description:
#### My project is named Fractal Drawer, because it allows you to choose a fractal from a list of several options and select its complexity, ranging from very simple to highly detailed. Program draws fractals via a built-in python library named “turtle”. On the screen, except the fractal itself, program also draws additional information: the name and the full name of fractal (for example, Sierpinski triangle, or Harter-Heighway Dragon), level of fractal complexity and the most important - the name of the creator of this project and its Motherland (me and Kazakhstan).

#### Why did I choose this particular idea for my project? There are a few reasons: I experienced working with python turtle library several years ago, when I only started my journey in programming. SInce then, I forgot my skills in this library, and I wanted to restore and increase them, because I found it is very interesting and captivating to draw via code. Also, as an ex-olympiad programmer, I was passionate about the topic of fractals and I wanted to know more about them.

#### So, the structure of the project: it has 5 files in it. Firstly, it is a Fractal.py class consisting of all methods related to choosing and drawing fractals. First and foremost, it has a list of fractal names - 'Honeycomb', 'Triangle', 'Dragon', 'Snowflake', 'Tree', 'Complex tree'. Also, there is a dictionary with the range of all possible levels of complexity for each fractal. Then, it has a class method “print_fractals_list” that is supposed to print names of all available fractals to the console in the beginning of the program. For the sake of legibility and better user interface, I used python built-in library named colorama that edits the style of printed messages - every name of fractal is bold-styled and colored to a unique color (for example, white for Snowflake fractal and green for Tree fractal). Then it has two class methods to get user input - fractal you want to see drawed and its level of complexity. After that, the program creates an object of the DrawData class. This class that I made is a data class that stores information about names, generations, rules, draw color and angle of fractal. To start the process of drawing the fractal, the program should also decide its thickness, number of steps of the drawer turtle on each step, and its initial position. All of this information depends on the level of complexity of fractal, so I created a specific .csv file to store all of that. So, to start drawing, the program takes from a .csv file the information from a particular row that has the same complexity and fractal name that the user has chosen.

#### To draw fractals, you need to know its generation. Basically, it is a sort of cryptic row of symbols like this: “F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F”. So, to calculate this information based on the original “axiom” (unique for each type of fractal) and complexity, I made a class method “get_final_gen”.


#### After all of these steps, the program is ready to actually draw fractals. Drawing process of each fractal varies. But eventually, it is just the processing of fractal’s final generation, and the drawer turtle’s making some fraud on the screen based on the symbol the “for” loop currently at. For example, if it is a plus symbol, when drawing a Snowflake fractal turtle will turn to the right at some angle. And vica-versa, it will turn left when it faces the minus symbol in the row. Actually, there are two turtles. First is supposed to draw fractal, and second is supposed to draw additional information that I wrote about above. To manage the last, I made a special function “draw_information”.

#### A main function inside of project.py manages user input by using class methods of Fractal class and then calls its “draw_fractal_template” to draw fractal.

#### Test_project.py tests 3 additional functions and methods, using pytest library’s “assert” and .raises() keywords.

